//
//  UIFont+DMSAdditions.swift
//
//  Generated by Zeplin on 11/8/16.
//  Copyright (c) 2016 __MyCompanyName__. All rights reserved. 
//

import UIKit

let kLowBatteryLevel = 30

struct Font{
    static let GothamBold = "GothamHTF-Bold"
    static let GothamBook = "GothamHTF-Book"
    static let GothamMedium = "GothamHTF-Medium"
}

struct ErrorMessages {
    static let noError = "NO ERROR"
    static let knownError = "KNOWN ERROR"
    static let unknownError = "UNKNOWN ERROR"
    static let parsingError = "PARSING ERROR"
    static let disclaimerNotAccepted = "You must accept T&C and PP"
}

struct iHealthCredentials {
    
    //Production
    static let clientId = "256e134715c14ed9baaa897044bb8e65"
    static let clientSecret = "a37c426dadb44df38114217728678c18"
    static let userId = "sasha@datamindedsolutions.com"

    
    //Staging
//    static let clientId = "aabe25099272416ebdbc21579b1050ea"
//    static let clientSecret = "12f3dcb6ff324cbe834c164b4420f206"
//    static let userId = "sasha@datamindedsolutions.com"

    
    //Sample app keys:
//    static let clientId = "2a8387e3f4e94407a3a767a72dfd52ea"
//    static let clientSecret = "fd5e845c47944a818bc511fb7edb0a77"
//    static let userId = "he@12.com"
}

struct RestUrl {
    
    //Staging
//    static let baseUrl = "https://staging-app.noteworth.com/api/"
    
    //Production:
    static let baseUrl = "https://app.noteworth.com/api/"
    
    //Patients
    static let createTestPatient = baseUrl + "patients/create_test"
    static let getAuthHeader = baseUrl + "api-token-auth/"

    static let notificationSettings = baseUrl + "notification-settings"
    static let users = baseUrl + "users/me"
    static let patients = baseUrl + "patients/me"
    static let devices = baseUrl + "devices"
    static let device = baseUrl + "device"
    static let registerPushNotifications = baseUrl + "notification-settings"

    static let disclaimerConsents = baseUrl + "disclaimer-consents"

    static let readings = baseUrl + "readings"
    static let bloodPressureReadings = readings + "/heart"
    static let glucoseReadings = readings + "/glucose"
    static let fitnessReadings = readings + "/fitness"
    static let nutritionReadings = readings + "/nutrition"
    static let sleepReadings = readings + "/sleep"
    static let weightReadings = readings + "/weight"
    static let routineReadings = readings + "/routine"
    
    static let clarityHistory = baseUrl + "patients/clarity_score_history"
    static let healthCarePartners = baseUrl + "clarity-partners"

}

struct UserDefaultsStrings {
    static let authToken = "authToken"
    static let glucoseReadingsCount = "glucoseReadingsCount"
    static let glucoseMax = "glucoseMax"
    static let glucoseMin = "glucoseMin"
    static let beforeMealAverage = "beforeMealAverage"
    static let afterMealAverage = "afterMealAverage"
    static let unitForApp = "unitForApp"
    static let coreDataFilled = "coreDataFilled"
    static let bottleCode = "bottleCode"
    static let misfitSerialNumber = "misfitSerialNumber"
    static let numberOfStrips = "numberOfStrips"

    static let bloodPressureBatteryLevel = "bloodPressureBatteryLevel"
    static let glucoseBatteryLevel = "glucoseBatteryLevel"
    static let misfitBatteryLevel = "misfitBatteryLevel"
    static let scaleBatteryLevel = "scaleBatteryLevel"

    static let misfitProblemAlertShown = "misfitProblemAlertShown"
    static let misfitSet = "misfitSet"
    static let bloodPressureDeviceSet = "bloodPressureDeviceSet"
    static let glucoseDeviceSet = "glucoseDeviceSet"
    
    static let joyrideState = "joyrideState"
    static let joyrideSet = "joyrideSet"
    
    static let joyrideCardiologySet = "joyrideCardiologySet"
    static let joyrideGlucoseSet = "joyrideGlucoseSet"
    static let joyrideActivitySet = "joyrideActivitySet"

}

struct NotificationNames {
    static let unitChanged = "unitChanged"
    static let startDataSync = "startDataSync"
    static let refreshSleepReadings = "refreshSleepReadings"
    static let refreshWeightReadings = "refreshWeightReadings"
    static let refreshActivityReadings = "refreshActivityReadings"
    static let sleepReadingEdited = "sleepReadingEdited"
    static let sleepReadingDeleted = "sleepReadingDeleted"
    static let weightReadingEdited = "weightReadingEdited"
    static let weightReadingDeleted = "weightReadingDeleted"
    static let fetchStarted = "fetchStarted"
    static let fetchFinished = "fetchFinished"
    static let fitnessReadingEdited = "fitnessReadingEdited"
    static let fitnessReadingDeleted = "fitnessReadingDeleted"
    static let refreshRoutineReadings = "refreshRoutineReadings"
    static let routineReadingEdited = "routineReadingEdited"
    static let routineReadingDeleted = "routineReadingDeleted"
    static let goToBloodPressureHistory = "goToBloodPressureHistory"
    static let misfitSyncFinished = "misfitSyncFinished"
    static let misfitSyncOver = "misfitSyncOver"
    static let pageMenuMoveToPage = "pageMenuMoveToPage"
    static let backToWeightGraph = "backToWeightGraph"
    static let sendAPNSToken = "sendAPNSToken"

}

struct DmsAppLinks {
    static let legalAgreements = "https://www.noteworth.com/legal/privacy"
    static let termsOfUse = "https://www.noteworth.com/legal/terms"
    static let faq = "http://help.noteworth.com"
    static let feedbackEmail = "feedback@noteworth.com"
    static let supportEmail = "help@noteworth.com"
    static let appSupport = "http://help.noteworth.com/collection/160-app"
    static let forgotPassword = "https://app.noteworth.com/user/password/reset/"
    static let clarityPartnerInfo = "https://noteworth.helpscoutdocs.com/category/197-clarity-partner"
    static let clarityPointsInfo = "https://noteworth.helpscoutdocs.com/category/201-clarity-points"
}

struct HeapCredentials{
    static let appId = "667419576"
}

struct GlobalGraph {
    static var minimum : Int = 0
}

struct GlobalDeviceSetup {
    static var bloodPressure : Bool = false
}

enum GraphPeriod : Int {
    case Week = 0
    case TwoWeeks
    case Month
    case ThreeMonths
    
    var description : String! {
        switch self {
        case .Week:
            return "Week"
        case .TwoWeeks:
            return "2 Weeks"
        case .Month:
            return "Month"
        case .ThreeMonths:
            return "3 Months"
        }
    }
    
    var days : Int! {
        switch self {
        case .Week:
            return 8
        case .TwoWeeks:
            return 13
        case .Month:
            return 30
        case .ThreeMonths:
            return 91
        }
    }
    var daysToShowOnX : Int! {
        switch self {
        case .Week:
            return 9
        case .TwoWeeks:
            return 7
        case .Month:
            return 3
        case .ThreeMonths:
            return 3
        }
    }
}

public enum PageMenuItemType : Int {
    case Steps = 0
    case Activity
    case Sleep
    case Weight
}

public enum UnitType : Int {
    case imperial
    case metric
    
    var description:String! {
        switch self{
        case .imperial:
            return "Imperial"
        case .metric:
            return "Metric"
        }
    }
}

public enum StepsGoal : Int {
    case light
    case moderate
    case heavy
    
    var jsonRepresentation:String! {
        switch self{
        case .light:
            return "light"
        case .moderate:
            return "moderate"
        case .heavy:
            return "heavy"
        }
    }
}

public enum MailType : Int {
    case support
    case feedback
    
    var emailAddress:String! {
        switch self{
        case .support:
            return DmsAppLinks.supportEmail
        case .feedback:
            return DmsAppLinks.feedbackEmail
        }
    }
    
    var subject:String! {
        switch self{
        case .support:
            return "Help with Noteworth"
        case .feedback:
            return "Noteworth App Feedback"
        }
    }
}

enum ActivityType : String {
    case activity = "Activity"
    case sleep = "Sleep"
    case weight = "Weight"
    
    var image:UIImage! {
        switch self{
        case .activity:
            return #imageLiteral(resourceName: "iconActivity04Heavy")
        case .sleep:
            return #imageLiteral(resourceName: "iconActivitySleep")
        case .weight:
            return #imageLiteral(resourceName: "popupIconWeight")
        }
    }
    
    var selectedImage:UIImage! {
        switch self{
        case .activity:
            return #imageLiteral(resourceName: "iconActivity04HeavySelected")
        case .sleep:
            return #imageLiteral(resourceName: "iconActivitySleepSelected")
        case .weight:
            return #imageLiteral(resourceName: "popupIconWeightSelected")
        }
    }

}

enum MealTime : Int {
    case beforeMeal = 0
    case afterMeal
    case beforeBreakfast
    case afterBreakfast
    case beforeLunch
    case afterLunch
    case beforeDinner
    case afterDinner
    case bedtime
    case snack
    case random
    case nothingSelected
    
    var description:String! {
        switch self{
        case .beforeMeal:
            return "Before Meal"
        case .afterMeal:
            return "After Meal"
        case .beforeBreakfast:
            return "Before Breakfast"
        case .afterBreakfast:
            return "After Breakfast"
        case .beforeLunch:
            return "Before Lunch"
        case .afterLunch:
            return "After Lunch"
        case .beforeDinner:
            return "Before Dinner"
        case .afterDinner:
            return "After Dinner"
        case .bedtime:
            return "Bedtime"
        case .snack:
            return "Snack"
        case .random:
            return "Other"
        case .nothingSelected:
            return ""
        }
    }
    var jsonRepresentation:String! {
        switch self{
        case .beforeMeal:
            return "before_meal"
        case .afterMeal:
            return "after_meal"
        case .beforeBreakfast:
            return "before_breakfast"
        case .afterBreakfast:
            return "after_breakfast"
        case .beforeLunch:
            return "before_lunch"
        case .afterLunch:
            return "after_lunch"
        case .beforeDinner:
            return "before_dinner"
        case .afterDinner:
            return "after_dinner"
        case .bedtime:
            return "bedtime"
        case .snack:
            return "snack"
        case .random:
            return "random"
        case .nothingSelected:
            return ""
        }
    }
    var image:UIImage! {
        switch self{
        case .beforeMeal:
            return #imageLiteral(resourceName: "mealBeforeMeal")
        case .afterMeal:
            return #imageLiteral(resourceName: "mealAfterMeal")
        case .beforeBreakfast:
            return #imageLiteral(resourceName: "mealBeforeBreakfast")
        case .afterBreakfast:
            return #imageLiteral(resourceName: "mealAfterBreakfast")
        case .beforeLunch:
            return #imageLiteral(resourceName: "mealBeforeLunch")
        case .afterLunch:
            return #imageLiteral(resourceName: "mealAfterLunch")
        case .beforeDinner:
            return #imageLiteral(resourceName: "mealBeforeDinner")
        case .afterDinner:
            return #imageLiteral(resourceName: "mealAfterDinner")
        case .bedtime:
            return #imageLiteral(resourceName: "mealBedtime")
        case .snack:
            return #imageLiteral(resourceName: "mealAfterSnacks")
        case .random:
            return #imageLiteral(resourceName: "mealRandom")
        case .nothingSelected:
            return nil
        }
    }
    var imageSelected:UIImage! {
        switch self{
        case .beforeMeal:
            return #imageLiteral(resourceName: "mealBeforeMealSelected")
        case .afterMeal:
            return #imageLiteral(resourceName: "mealAfterMealSelected")
        case .beforeBreakfast:
            return #imageLiteral(resourceName: "mealBeforeBreakfastSelected")
        case .afterBreakfast:
            return #imageLiteral(resourceName: "mealAfterBreakfastSelected")
        case .beforeLunch:
            return #imageLiteral(resourceName: "mealBeforeLunchSelected")
        case .afterLunch:
            return #imageLiteral(resourceName: "mealAfterLunchSelected")
        case .beforeDinner:
            return #imageLiteral(resourceName: "mealBeforeDinnerSelected")
        case .afterDinner:
            return #imageLiteral(resourceName: "mealAfterDinnerSelected")
        case .bedtime:
            return #imageLiteral(resourceName: "mealBedtimeSelected")
        case .snack:
            return #imageLiteral(resourceName: "mealAfterSnacksSelected")
        case .random:
            return #imageLiteral(resourceName: "mealRandomSelected")
        case .nothingSelected:
            return nil
        }
    }
}

enum Activity : Int {
    case walking = 0
    case running
    case swimming
    case cycling
    case basketball
    case tennis
    case soccer
    case yoga
    case dancing
    case sports
    case other
    
    var description:String! {
        switch self{
        case .walking:
            return "Walking"
        case .running:
            return "Running"
        case .swimming:
            return "Swimming"
        case .cycling:
            return "Cycling"
        case .basketball:
            return "Basketball"
        case .tennis:
            return "Tennis"
        case .soccer:
            return "Soccer"
        case .yoga:
            return "Yoga"
        case .dancing:
            return "Dancing"
        case .sports:
            return "Sports"
        case .other:
            return "Other"
        }
    }
    var jsonRepresentation:String! {
        switch self{
        case .walking:
            return "walking"
        case .running:
            return "running"
        case .swimming:
            return "swimming"
        case .cycling:
            return "cycling"
        case .basketball:
            return "basketball"
        case .tennis:
            return "tennis"
        case .soccer:
            return "soccer"
        case .yoga:
            return "yoga"
        case .dancing:
            return "dancing"
        case .sports:
            return "sports"
        case .other:
            return "other"
        }
    }
    var image:UIImage! {
        switch self{
        case .walking:
            return #imageLiteral(resourceName: "walking")
        case .running:
            return #imageLiteral(resourceName: "running")
        case .swimming:
            return #imageLiteral(resourceName: "swimming")
        case .cycling:
            return #imageLiteral(resourceName: "cycling")
        case .basketball:
            return #imageLiteral(resourceName: "basketball")
        case .tennis:
            return #imageLiteral(resourceName: "tennis")
        case .soccer:
            return #imageLiteral(resourceName: "soccer")
        case .yoga:
            return #imageLiteral(resourceName: "yoga")
        case .dancing:
            return #imageLiteral(resourceName: "dancing")
        case .sports:
            return #imageLiteral(resourceName: "sports")
        case .other:
            return #imageLiteral(resourceName: "other")
        }
    }
    var imageSelected:UIImage! {
        switch self{
        case .walking:
            return #imageLiteral(resourceName: "walkingSelected")
        case .running:
            return #imageLiteral(resourceName: "runningSelected")
        case .swimming:
            return #imageLiteral(resourceName: "swimmingSelected")
        case .cycling:
            return #imageLiteral(resourceName: "cyclingSelected")
        case .basketball:
            return #imageLiteral(resourceName: "basketballSelected")
        case .tennis:
            return #imageLiteral(resourceName: "tennisSelected")
        case .soccer:
            return #imageLiteral(resourceName: "soccerSelected")
        case .yoga:
            return #imageLiteral(resourceName: "yogaSelected")
        case .dancing:
            return #imageLiteral(resourceName: "dancingSelected")
        case .sports:
            return #imageLiteral(resourceName: "sportsSelected")
        case .other:
            return #imageLiteral(resourceName: "otherSelected")
        }
    }
}


enum Mood : String {
    case NoMood = ""
    case Happy = "Happy"
    case Ok = "Neutral"
    case Neutral = "Stressed"
    case Sad = "Sad"
    
    var jsonRepresentation:String? {
        switch self{
        case .NoMood:
            return nil
        case .Happy:
            return "happy"
        case .Ok:
            return "neutral"
        case .Neutral:
            return "stressed"
        case .Sad:
            return "sad"
        }
    }
    var intRepresentation: Int! {
        switch self{
        case .NoMood:
            return 0
        case .Happy:
            return 1
        case .Ok:
            return 2
        case .Neutral:
            return 3
        case .Sad:
            return 4
        }
    }
    
    var image: UIImage? {
        switch self{
        case .NoMood:
            return nil
        case .Happy:
            return #imageLiteral(resourceName: "iconFace01Happy")
        case .Ok:
            return #imageLiteral(resourceName: "iconFace02Ok")
        case .Neutral:
            return #imageLiteral(resourceName: "iconFace03Neutral")
        case .Sad:
            return #imageLiteral(resourceName: "iconFace04Sad")
        }
    }
}
enum ActivityGlucose : String {
    case noActivity = ""
    case low = "Low"
    case light = "Light"
    case moderate = "Moderate"
    case heavy = "Heavy"
    
    var jsonRepresentation:String?{
        switch self{
        case .noActivity:
            return nil
        case .low:
            return "Low"
        case .light:
            return "Light"
        case .moderate:
            return "Moderate"
        case .heavy:
            return "Heavy"
        }
    }
    
    var intRepresentation: Int! {
        switch self {
        case .noActivity:
            return 0
        case .low:
            return 1
        case .light:
            return 2
        case .moderate:
            return 3
        case .heavy:
            return 4
        }
    }
}

enum ActivityBP : String {
    
    case noActivity = ""
    case light = "Light"
    case moderate = "Moderate"
    case heavy = "Heavy"
    case coffee = "Caffeine"
    case meal = "Meal"
    case other = "Other"
    
    var jsonRepresentation:String?{
        switch self{
        case .noActivity:
            return nil
        case .light:
            return "light"
        case .moderate:
            return "moderate"
        case .heavy:
            return "heavy"
        case .coffee:
            return "caffeine"
        case .meal:
            return "meal"
        case .other:
            return "other"

        }
    }
    
    var intRepresentation: Int! {
        switch self {
        case .noActivity:
            return 0
        case .light:
            return 1
        case .moderate:
            return 2
        case .heavy:
            return 3
        case .coffee:
            return 4
        case .meal:
            return 5
        case .other:
            return 6
        }
    }
    
    var image: UIImage? {
        switch self {
        case .noActivity:
            return nil
        case .light:
            return #imageLiteral(resourceName: "iconActivity02LightSelected")
        case .moderate:
            return #imageLiteral(resourceName: "iconActivity03ModerateSelected")
        case .heavy:
            return #imageLiteral(resourceName: "iconActivity04HeavySelected")
        case .coffee:
            return #imageLiteral(resourceName: "coffeeSelected")
        case .meal:
            return #imageLiteral(resourceName: "mealSelected")
        case .other:
            return #imageLiteral(resourceName: "otherSelected")
        }
    }

}

enum TextFieldTag : Int {
    case firstName
    case lastName
    case email
    case password
    case confirmPassword
    case mobilePhoneNumber
    case name
    
    var description:String{
        switch self{
        case .firstName:
            return "First Name"
        case .lastName:
            return "Last Name"
        case .email:
            return "Email"
        case .password:
            return "Password"
        case .confirmPassword:
            return "Repeat Password"
        case .mobilePhoneNumber:
            return "Mobile Phone Number"
        case .name:
            return "Name"
        }
    }
}

extension UILabel {
    func addTextSpacing(_ spacing:CGFloat){
        if let text = self.text{
            let attributedString = NSMutableAttributedString(string: text)
            attributedString.addAttribute(NSKernAttributeName, value: CGFloat(spacing), range: NSRange(location: 0, length: text.characters.count))
            self.attributedText = attributedString
        }
    }
}

extension UIViewController {
    
    
    enum Name : String {
        case FirstName = "First name"
        case LastName = "Last name"
    }
    
    func checkMaxLength(textField: UITextField!, maxLength: Int) {
        if ((textField.text?.characters.count)! > maxLength) {
            textField.deleteBackward()
        }
    }
    
    func returnPhoneNumberDigits(phoneNumber: String)->String {
        
        var phoneNumber = phoneNumber
        phoneNumber = phoneNumber.replacingOccurrences(of: "(", with: "")
        phoneNumber = phoneNumber.replacingOccurrences(of: ")", with: "")
        phoneNumber = phoneNumber.replacingOccurrences(of: "-", with: "")
        return phoneNumber
        
    }
    
    
    
    func checkName(name: String, type: Name, length: Int) -> (isTrue: Bool, message: String) {
        if name.characters.count < length {
            return (isTrue: false, message: "\(type.rawValue) should be \(length) or more characters long")
        }else if !name.nameValid(){
            return (isTrue: false, message: "Name should contain characters only")
        }else{
            return (isTrue: true, message: "OK")
        }
    }
    
    func checkPassword(password: String, confirmPassword: String, length: Int) -> (isTrue: Bool, message: String) {
        
        if password.characters.count < length {
            return (isTrue: false, message: "Password should be \(length) or more characters long")
        }else if password != confirmPassword {
            return (isTrue: false, message: "Passwords don't match")
        }else if !password.containsLetter() {
            return (isTrue: false, message: "At least one letter required")
        }else if !password.containsNumber() && !password.containsSpecialCharacters() {
            return (isTrue: false, message: "At least one digit or symbol required")
        }else {
            return (isTrue: true, message: "OK")
        }
        
    }
    
    func isFuture(date: Date) -> Bool {
        if date > Date() {
            return true
        }else{
            return false
        }
    }
    
    func isToday(date: Date) -> Bool {
        return Calendar.current.isDateInToday(date)
    }
    
    func getDate(date: String) -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: "GMT+0:00")
        dateFormatter.dateFormat = "MM/dd/yyyy"
        return dateFormatter.date(from: date)

    }
}

extension String {
    
    public func isValidWeight() -> Bool {
        let weightRegex = "[0-9]{0,3}(\\.[0-9]{0,2})?"
        let weightTest = NSPredicate(format:"SELF MATCHES %@", weightRegex)
        return weightTest.evaluate(with: self)
    }
    
    func isDateValid() -> Bool {
        let dateRegEx =  "((0[1-9])|(1[012]))/((0[1-9])|([12][0-9])|(3[01]))/((19\\d\\d)|(20\\d\\d))" //"(0[1-9]|1[012])/(0[1-9]|[12][0-9]3[01])/(19\\d\\d)|(20\\d\\d)"
        
        let dateTest = NSPredicate(format:"SELF MATCHES %@", dateRegEx)
        return dateTest.evaluate(with: self)

    }
    
    func isValidEmail() -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}"
        
        let emailTest = NSPredicate(format:"SELF MATCHES %@", emailRegEx)
        return emailTest.evaluate(with: self)
    }
    
    func containsNumber() -> Bool {
        let passRegEx = ".*[0-9]+.*"
        
        let passTest = NSPredicate(format:"SELF MATCHES %@", passRegEx)
        return passTest.evaluate(with: self)
        
    }
    
    func containsLetter() -> Bool {
        let passRegEx = ".*[a-zA-Z]+.*"
        
        let passTest = NSPredicate(format:"SELF MATCHES %@", passRegEx)
        return passTest.evaluate(with: self)
        
    }
    
    func containsSpecialCharacters() -> Bool {
        let passRegEx = ".*[^A-Za-z0-9].*"
        
        let passTest = NSPredicate(format:"SELF MATCHES %@", passRegEx)
        return passTest.evaluate(with: self)
        
    }
    
    func nameValid() -> Bool {
        let nameRegEx = "[A-Za-z -]+"
        
        let nameTest = NSPredicate(format:"SELF MATCHES %@", nameRegEx)
        return nameTest.evaluate(with: self)
    }
    func getBasicDate() -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: "GMT+0:00")
        dateFormatter.dateFormat = "yyyy-MM-dd"
        return dateFormatter.date(from: self)
    }
    
    func getCompleteDate() -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MM/dd/yyyy hh:mm a"
        return dateFormatter.date(from: self)
    }
    
    func getLocalTimeFromUTCTimestamp() -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
        
        if dateFormatter.date(from: self) == nil {
            dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
        }
        return dateFormatter.date(from: self)
    }
    
    func getDateFromTimestamp(utcOffset: String?) -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
        
        if dateFormatter.date(from: self) == nil {
            dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
        }
        return dateFormatter.date(from: self)
    }

    func getStartDateFromTimestamp(utcOffset: String?) -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
        return dateFormatter.date(from: self)
    }
    subscript (r: CountableClosedRange<Int>) -> String {
        get {
            let startIndex =  self.index(self.startIndex, offsetBy: r.lowerBound)
            let endIndex = self.index(startIndex, offsetBy: r.upperBound - r.lowerBound)
            return self[startIndex...endIndex]
        }
    }
    
}

extension Double {
    
    func getDateFromTimestamp(offsetMinutes: Int16?) -> String {
        
        let date = NSDate(timeIntervalSince1970: self) as Date
        let dateFormatter = DateFormatter()
        var seconds = 0
        if let minutes = offsetMinutes {
            seconds = Int(minutes) * 60
        }
        dateFormatter.timeZone = TimeZone(secondsFromGMT: seconds)
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return dateFormatter.string(from: date)
    }
    
    func convertToHoursAndMinutes() -> (hours: Int, min: Int) {
        let hours : Int!
        let minutes : Int!
        
        hours = Int(self/60.0)
        minutes = Int(self)%60
        
        return (hours: hours, min: minutes)
    }
    
    func getHoursApprox() -> Double{
        let hours : Int!
        let minutes : Int!
        
        hours = Int(self/60.0)
        minutes = Int(self)%60
        
        let minApp : Double = Double(minutes)/60
        return Double(hours)+minApp
    }
    
    func getHoursAndMinutesString() -> String {
        let hours : Int!
        let minutes : Int!
        
        hours = Int(self/60.0)
        minutes = Int(self)%60
        
        return String(hours) + " h " + String(minutes) + " m"
    }
    
}

extension Double {
    
    func convertHeightFromMetricToImperial() -> (feets: UInt, inches: UInt) {
        let inchesTotal = (self/2.54).rounded()
        let feets = floor(inchesTotal/12.0)
        let inches = (inchesTotal - feets * 12)
        let feetsInt = UInt(feets)
        let inchesInt = UInt(inches)
        return (feets: feetsInt, inches: inchesInt)
    }
    
    func convertWeightFromMetricToImperialOneDecimal() -> Double {
        return Darwin.round(self*2.2046*10)/10
    }

    func convertWeightFromImperialToMetricOneDecimal() -> Double {
        return Darwin.round(self/2.2046*10)/10
    }
    
    func convertWeightFromMetricToImperial() -> Double {
        return Darwin.round(self*2.2046*1000000)/1000000
    }
    
    func convertWeightFromImperialToMetric() -> Double {
        return Darwin.round(self/2.2046*1000000)/1000000
    }
}

extension UITextField {
    func setDoneToolbar(){
        let toolbar = UIToolbar(frame: CGRect(x: 0, y: 0, width: 100, height: 44))
        let flexibleSpace = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: self, action: nil)
        
        let toolbarRightButton = UIBarButtonItem(title: "Done".uppercased(), style: UIBarButtonItemStyle.plain, target: self, action: #selector(resignFirstResponder))
        toolbarRightButton.setTitleTextAttributes([NSFontAttributeName: UIFont(name: Font.GothamBold, size: 17.0)!], for: UIControlState.normal)
        toolbar.barTintColor = UIColor.dmsOffBlue
        toolbar.isTranslucent = false
        
        let tap = UITapGestureRecognizer(target: self, action: #selector(resignFirstResponder))
        toolbar.addGestureRecognizer(tap)
        
        toolbarRightButton.tintColor = UIColor.white
        toolbar.items = [flexibleSpace, toolbarRightButton, flexibleSpace]
        inputAccessoryView = toolbar
    }
}

extension Int {
    func timezoneOffset() -> String {
        
        let hours = abs(self)/60/60
        let minutes = (abs(self)/60)%60
        
        if self < 0 {
            if hours < 10 {
                if minutes < 10 {
                    return "-0\(hours):0\(minutes)"
                }else{
                    return "-0\(hours):\(minutes)"
                }
            }else{
                if minutes < 10 {
                    return "-\(hours):0\(minutes)"
                }else{
                    return "-\(hours):\(minutes)"
                }
            }
        }else{
            if hours < 10 {
                if minutes < 10 {
                    return "+0\(hours):0\(minutes)"
                }else{
                    return "+0\(hours):\(minutes)"
                }
            }else{
                if minutes < 10 {
                    return "+\(hours):0\(minutes)"
                }else{
                    return "+\(hours):\(minutes)"
                }
            }
        }
    }
}
//extension UInt {
//    
//    func convertCmsToFtAndInches() -> (feets: UInt, inches: UInt) {
//        let inchesTotal = Double(self)/2.54
//        let feets = floor(inchesTotal/12.0)
//        let inches = round(inchesTotal - feets * 12)
//        let feetsInt = UInt(feets)
//        let inchesInt = UInt(inches)
//        return (feets: feetsInt, inches: inchesInt)
//    }
//    
//    func convertKgsToLbs() -> UInt {
//        let lbs = round(Double(self) * 2.2046)
//        return UInt(lbs)
//    }
//    
//    func convertLbsToKgs() -> UInt {
//        let kgs = round(Double(self) / 2.2046)
//        return UInt(kgs)
//    }
//}
//
extension Date {
    
    func weeksFromDate(_ toDate: Date) -> Int? {
        return Calendar.current.dateComponents([.weekOfYear], from: self, to: toDate).weekOfYear
    }
    func daysFromDate(_ toDate: Date) -> Int? {
        return Calendar.current.dateComponents([.day], from: self, to: toDate).day
    }
    func monthsFromDate(_ toDate: Date) -> Int? {
        return Calendar.current.dateComponents([.month], from: self, to: toDate).month
    }
    func yearsFromDate(_ toDate: Date) -> Int? {
        return Calendar.current.dateComponents([.year], from: self, to: toDate).year
    }
    
    func getTimePeriodDescription(toDate: Date) -> String {
        
        let days = self.daysFromDate(toDate) ?? 0
        let weeks = self.weeksFromDate(toDate) ?? 0
        let months = self.monthsFromDate(toDate) ?? 0
        
        let currentWeek = Calendar.current.dateComponents([.weekOfMonth], from: toDate).weekOfMonth
        let currentMonth = Calendar.current.dateComponents([.month], from: toDate).month
        let currentYear = Calendar.current.dateComponents([.year], from: toDate).year
        
        let dateWeek = Calendar.current.dateComponents([.weekOfMonth], from: self).weekOfMonth
        let dateMonth = Calendar.current.dateComponents([.month], from: self).month
        let dateYear = Calendar.current.dateComponents([.year], from: self).year
        
        
        let yearDifference = (currentYear ?? 0) - (dateYear ?? 0)
        var monthDifference = 0
        
        if yearDifference == 0 {
            monthDifference = (currentMonth ?? 0) - (dateMonth ?? 0)
        }else if yearDifference == 1 {
            if (currentMonth ?? 0) - (dateMonth ?? 0) < 0 {
                monthDifference = 12 - abs((currentMonth ?? 0) - (dateMonth ?? 0))
            }else{
                monthDifference = 12 + abs((currentMonth ?? 0) - (dateMonth ?? 0))
            }
        }else {
            monthDifference = 24
        }
        let weekDifference = (currentWeek ?? 0) - (dateWeek ?? 0)
        
        if yearDifference >= 2 {
            return "\(yearDifference) years ago"
        }else{
            if monthDifference >= 12 {
                return "Last year"
            } else {
                if (monthDifference == 0) || (monthDifference == 1 && months == 0) {
                    if (weeks == 0 || weeks == 1) && (weekDifference == 1 || weekDifference < 0) && days >= 7 {
                        return "Last week"
                    }else{
                        if days >= 7 {
                            if weekDifference > 0 {
                                return "\(weekDifference) weeks ago"
                            }else{
                                return "\(weeks) weeks ago"
                            }
                        }else{
                            if days == 0 {
                                return "Today"
                            }else if days == 1 {
                                return "Yesterday"
                            }else{
                                return "\(days) days ago"
                            }
                        }
                    }
                }
                else if monthDifference == 1 {
                    return "Last month"
                }
                else {
                    return "\(monthDifference) months ago"
                }
            }
        }
    }
    
    func getLocalShortDate() -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MM/dd/yyyy"
        return dateFormatter.string(from: self)
    }
    func getLocalShortTime() -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "hh:mm a"
        return dateFormatter.string(from: self)
    }
    func getShortDate(utcOffset: String?) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        dateFormatter.dateFormat = "MM/dd/yyyy"
        return dateFormatter.string(from: self)
    }
    func getGraphDate(utcOffset: String?) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        dateFormatter.dateFormat = "MM/dd/yyyy"
        return dateFormatter.string(from: self)
    }
    func getShortTime(utcOffset: String?) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        dateFormatter.dateFormat = "hh:mm a"
        return dateFormatter.string(from: self)
        
    }
    func getTimestamp(utcOffset: String?) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS"
        return dateFormatter.string(from: self)
    }
    func getLongDateAndTime(utcOffset: String?) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMM d, yyyy hh:mm a"
        dateFormatter.timeZone = TimeZone(abbreviation: utcOffset ?? "GMT+0:00")
        return dateFormatter.string(from: self)
    }
    func getBirthdateString() -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone(abbreviation: "GMT+0:00")
        dateFormatter.dateFormat = "MMM d, yyyy"
        return dateFormatter.string(from: self)
    }

}

